#include <ti/screen.h>
#include <ti/getkey.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "aes.h"

/*
 * NIST SP 800-38D Test Case 4 (AES-128-GCM with AAD)
 * Source: GCM Specification (gcm-spec.pdf), Appendix B, Test Case 4
 */
uint8_t gcm_key[] = {
    0xfe,0xff,0xe9,0x92,0x86,0x65,0x73,0x1c,0x6d,0x6a,0x8f,0x94,0x67,0x30,0x83,0x08
};
uint8_t gcm_iv[] = {
    0xca,0xfe,0xba,0xbe,0xfa,0xce,0xdb,0xad,0xde,0xca,0xf8,0x88
};
uint8_t gcm_plaintext[] = {
    0xd9,0x31,0x32,0x25,0xf8,0x84,0x06,0xe5,0xa5,0x59,0x09,0xc5,0xaf,0xf5,0x26,0x9a,
    0x86,0xa7,0xa9,0x53,0x15,0x34,0xf7,0xda,0x2e,0x4c,0x30,0x3d,0x8a,0x31,0x8a,0x72,
    0x1c,0x3c,0x0c,0x95,0x95,0x68,0x09,0x53,0x2f,0xcf,0x0e,0x24,0x49,0xa6,0xb5,0x25,
    0xb1,0x6a,0xed,0xf5,0xaa,0x0d,0xe6,0x57,0xba,0x63,0x7b,0x39
};
uint8_t gcm_aad[] = {
    0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,0xfe,0xed,0xfa,0xce,0xde,0xad,0xbe,0xef,
    0xab,0xad,0xda,0xd2
};
uint8_t gcm_ciphertext[] = {
    0x42,0x83,0x1e,0xc2,0x21,0x77,0x74,0x24,0x4b,0x72,0x21,0xb7,0x84,0xd0,0xd4,0x9c,
    0xe3,0xaa,0x21,0x2f,0x2c,0x02,0xa4,0xe0,0x35,0xc1,0x7e,0x23,0x29,0xac,0xa1,0x2e,
    0x21,0xd5,0x14,0xb2,0x54,0x66,0x93,0x1c,0x7d,0x8f,0x6a,0x5a,0xac,0x84,0xaa,0x05,
    0x1b,0xa3,0x0b,0x39,0x6a,0x0a,0xac,0x97,0x3d,0x58,0xe0,0x91
};
uint8_t gcm_tag[] = {
    0x5b,0xc9,0x4f,0xbc,0x32,0x21,0xa5,0xdb,0x94,0xfa,0xe9,0x5a,0xe7,0x12,0x1a,0x47
};

/*
 * NIST SP 800-38A AES-128-CBC Test Vector
 * Source: SP 800-38A, Appendix F.2.1 (CBC-AES128.Encrypt)
 */
uint8_t cbc_key[] = {
    0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c
};
uint8_t cbc_iv[] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f
};
uint8_t cbc_plaintext[] = {
    0x6b,0xc1,0xbe,0xe2,0x2e,0x40,0x9f,0x96,0xe9,0x3d,0x7e,0x11,0x73,0x93,0x17,0x2a,
    0xae,0x2d,0x8a,0x57,0x1e,0x03,0xac,0x9c,0x9e,0xb7,0x6f,0xac,0x45,0xaf,0x8e,0x51,
    0x30,0xc8,0x1c,0x46,0xa3,0x5c,0xe4,0x11,0xe5,0xfb,0xc1,0x19,0x1a,0x0a,0x52,0xef,
    0xf6,0x9f,0x24,0x45,0xdf,0x4f,0x9b,0x17,0xad,0x2b,0x41,0x7b,0xe6,0x6c,0x37,0x10
};
uint8_t cbc_ciphertext[] = {
    0x76,0x49,0xab,0xac,0x81,0x19,0xb2,0x46,0xce,0xe9,0x8e,0x9b,0x12,0xe9,0x19,0x7d,
    0x50,0x86,0xcb,0x9b,0x50,0x72,0x19,0xee,0x95,0xdb,0x11,0x3a,0x91,0x76,0x78,0xb2,
    0x73,0xbe,0xd6,0xb8,0xe3,0xc1,0x74,0x3b,0x71,0x16,0xe6,0x9e,0x22,0x22,0x95,0x16,
    0x3f,0xf1,0xca,0xa1,0x68,0x1f,0xac,0x09,0x12,0x0e,0xca,0x30,0x75,0x86,0xe1,0xa7
};

static void show_result(bool ok)
{
    if (ok)
        printf("success");
    else
        printf("failed");
    os_GetKey();
    os_ClrHome();
}

/* Main function, called first */
int main(void)
{
    struct tls_aes_context ctx;
    uint8_t tbuf[100] = {0};
    uint8_t tag[TLS_AES_AUTH_TAG_SIZE];
    bool status = true;
    bool ok;

    os_ClrHome();

    // Test 1: AES-GCM encrypt (NIST SP 800-38D Test Case 4)
    status = true;
    memset(tbuf, 0, sizeof(tbuf));
    status &= tls_aes_init(&ctx, TLS_AES_GCM, gcm_key, sizeof gcm_key, gcm_iv, sizeof gcm_iv);
    status &= tls_aes_update_aad(&ctx, gcm_aad, sizeof gcm_aad);
    status &= tls_aes_encrypt(&ctx, gcm_plaintext, sizeof gcm_plaintext, tbuf);
    status &= tls_aes_digest(&ctx, tag);
    ok = status &&
         (memcmp(tbuf, gcm_ciphertext, sizeof gcm_ciphertext) == 0) &&
         (memcmp(tag, gcm_tag, TLS_AES_AUTH_TAG_SIZE) == 0);
    show_result(ok);

    // Test 2: AES-GCM decrypt (NIST SP 800-38D Test Case 4)
    status = true;
    memset(tbuf, 0, sizeof(tbuf));
    status &= tls_aes_init(&ctx, TLS_AES_GCM, gcm_key, sizeof gcm_key, gcm_iv, sizeof gcm_iv);
    status &= tls_aes_verify(&ctx, gcm_aad, sizeof gcm_aad, gcm_ciphertext, sizeof gcm_ciphertext, gcm_tag);
    status &= tls_aes_decrypt(&ctx, gcm_ciphertext, sizeof gcm_ciphertext, tbuf);
    ok = status && (memcmp(tbuf, gcm_plaintext, sizeof gcm_plaintext) == 0);
    show_result(ok);

    // Test 3: AES-CBC encrypt (NIST SP 800-38A F.2.1)
    status = true;
    memset(tbuf, 0, sizeof(tbuf));
    status &= tls_aes_init(&ctx, TLS_AES_CBC, cbc_key, sizeof cbc_key, cbc_iv, sizeof cbc_iv);
    status &= tls_aes_encrypt(&ctx, cbc_plaintext, sizeof cbc_plaintext, tbuf);
    ok = status && (memcmp(tbuf, cbc_ciphertext, sizeof cbc_ciphertext) == 0);
    show_result(ok);

    // Test 4: AES-CBC decrypt (NIST SP 800-38A F.2.1)
    status = true;
    memset(tbuf, 0, sizeof(tbuf));
    status &= tls_aes_init(&ctx, TLS_AES_CBC, cbc_key, sizeof cbc_key, cbc_iv, sizeof cbc_iv);
    status &= tls_aes_decrypt(&ctx, cbc_ciphertext, sizeof cbc_ciphertext, tbuf);
    ok = status && (memcmp(tbuf, cbc_plaintext, sizeof cbc_plaintext) == 0);
    show_result(ok);

    return 0;
}
